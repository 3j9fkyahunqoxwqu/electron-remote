{
  "name": "electron-remote",
  "tagline": "Execute JavaScript in remote Electron processes, but more betterer",
  "body": "# electron-remote: an asynchronous 'remote', and more\r\n\r\nelectron-remote provides an alternative to Electron's `remote` module based around Promises instead of synchronous execution. It also provides an automatic way to use BrowserWindows as \"background processes\" that auto-scales based on usage, similar to Grand Central Dispatch or the .NET TPL Taskpool.\r\n\r\n## The Quickest of Quick Starts\r\n\r\n###### Calling code in other windows\r\n\r\n```js\r\nimport { createProxyForRemote } from 'electron-remote';\r\n\r\n// myWindowJs is now a proxy object for myWindow's `window` global object\r\nconst myWindowJs = createProxyForRemote(myWindow);\r\n\r\n// Functions suffixed with _get will read a value\r\nuserAgent = await myWindowJs.navigator.userAgent_get()\r\n```\r\n\r\n###### Renderer Taskpool\r\n\r\n```js\r\nimport { requireTaskPool } from 'electron-remote';\r\n\r\nconst myCoolModule = requireTaskPool(require.resolve('./my-cool-module'));\r\n\r\n// This method will run synchronously, but in a background BrowserWindow process\r\n// so that your app will not block\r\nlet result = await myCoolModule.calculateDigitsOfPi(100000);\r\n```\r\n\r\n## But I like Remote!\r\n\r\nRemote is super convenient! But it also has some downsides - its main downside is that its action is **synchronous**. This means that both the main and window processes will _wait_ for a method to finish running. Even for quick methods, calling it too often can introduce scroll jank and generally cause performance problems. \r\n\r\nelectron-remote is a version of remote that, while less ergonomic, guarantees that it won't block the calling thread.\r\n\r\n## Using createProxyForRemote\r\n\r\n`createProxyForRemote` is a replacement for places where you would use Electron's `executeJavaScript` method on BrowserWindow or WebView instances - however, it works a little differently. Using a new feature in ES2015 called [proxy objects](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy), we create an object which represents the `window` object on a remote context, and all method calls get sent as messages to that remote instead of being run immediately, which feels very similar to the `remote` Electron module.\r\n\r\nThis provides a number of very important advantages:\r\n\r\n* `createProxyForRemote` uses asynchronous IPC instead of blocking\r\n* Parameters are serialized directly, so you don't have to try to build strings that can be `eval`d, which is a dangerous endeavor at best.\r\n* Calling methods on objects is far more convenient than trying to poke at things via a remote eval.\r\n\r\n#### How do I get properties if everything is a Promise tho???\r\n\r\nAstute observers will note, that getting the value of a property is always a synchronous operation - to facilitate that, any method with `_get()` appended to it will let you fetch the value for the property.\r\n\r\n```js\r\nimport { createProxyForRemote } from 'electron-remote';\r\n\r\n// myWindowJs is now a proxy object for myWindow's `window` global object\r\nconst myWindowJs = createProxyForRemote(myWindow);\r\n\r\n// Functions suffixed with _get will read a value\r\nmyWindowJs.navigator.userAgent_get()\r\n  .then((agent) => console.log(`The user agent is ${agent}`));\r\n```\r\n\r\n#### But do this first!\r\n\r\nBefore you use `createProxyForRemote`, you **must** call `initializeEvalHandler()` in the target window on startup. This sets up the listeners that electron-remote will use.\r\n\r\n#### Bringing it all together\r\n\r\n```js\r\n// In my window's main.js\r\ninitializeEvalHandler();\r\nwindow.addNumbers = (a,b) => a + b;\r\n\r\n\r\n// In my main process\r\nlet myWindowProxy = createProxyForRemote(myWindow);\r\nmyWindowProxy.addNumbers(5, 5)\r\n  .then((x) => console.log(x));\r\n  \r\n>>> 10\r\n```\r\n\r\n## Here Be Dragons\r\n\r\nelectron-remote has a number of significant caveats versus the remote module that you should definitely be aware of:\r\n\r\n* Remote values must be Serializable\r\n\r\nObjects that you return to the calling process must be serializable (i.e. you can call `JSON.stringify` on it and get a valid thing)- this means that creating Classes won't work, nor will return objects like BrowserWindows or other Electron objects. For example:\r\n\r\n```js\r\nlet myWindowProxy = createProxyForRemote(myWindow);\r\n\r\n// XXX: BAD - HTML elements aren't serializable\r\nlet obj = myWindowProxy.document.createElement('h1');\r\n```\r\n\r\n* Remote event listeners aren't supported\r\n\r\nAnything that involves an event handler isn't going to work:\r\n\r\n```js\r\n// XXX: BAD - You can't add event handlers\r\nmyWindowProxy.document.addEventListener('onBlur', (e) => console.log(\"Blur!\"));\r\n```\r\n\r\n## The Renderer Taskpool\r\n\r\nRenderer Taskpools provide an automatic way to use BrowserWindows as \"background processes\" that auto-scales based on usage, similar to Grand Central Dispatch or the .NET TPL Taskpool. This works by allowing you to provide a Module that you'd like to load in the remote processes, which will be loaded and unloaded on the fly according to demand.\r\n\r\nLet's look at the example again:\r\n\r\n```js\r\nimport { requireTaskPool } from 'electron-remote';\r\n\r\nconst myCoolModule = requireTaskPool(require.resolve('./my-cool-module'));\r\n\r\n// This method will run synchronously, but in a background BrowserWindow process\r\n// so that your app will not block\r\nlet result = await myCoolModule.calculateDigitsOfPi(100000);\r\n```\r\n\r\nBy default, `requireTaskPool` will create up to four background processes to concurrently run JS code on. As these processes become busy, requests will be queued to different processes and wait in line implicitly.\r\n\r\n##### More Dragons\r\n\r\nSince `requireTaskPool` will create and destroy processes as needed, this means that global variables or other state will be destroyed as well. You can't rely on setting a global variable and having it persist for a period of time longer than one method call.\r\n\r\n## The remote-ajax module\r\n\r\nOne module that is super useful to have from the main process is a way to make network requests using Chromium's networking stack, which correctly does things such as respecting the system proxy settings. To this end, electron-remote comes with a convenient wrapper around Rx-DOM's AJAX methods called `remote-ajax`.\r\n\r\n```js\r\nimport { requireTaskPool } from 'electron-remote';\r\n\r\nconst remoteAjax = requireTaskPool(require.resolve('electron-remote/remote-ajax'));\r\n\r\n// Result is the object that XmlHttpRequest gives you\r\nlet result = await remoteAjax.get('https://httpbin.org/get');\r\nconsole.log(result.url)\r\n\r\n>>> 'https://httpbin.org/get'\r\n```\r\n\r\nSee the documentation for [Rx-DOM](https://github.com/Reactive-Extensions/RxJS-DOM/blob/master/modules/main-ajax/readme.md) for how these methods work.\r\n\r\nAnother method that is included is `downloadFileOrUrl`, which lets you download a file to a target:\r\n\r\n```js\r\n/**\r\n * Downloads a path as either a file path or a HTTP URL to a specific place\r\n *\r\n * @param  {string} pathOrUrl   Either an HTTP URL or a file path.\r\n * @return {string}             The contents as a UTF-8 decoded string.\r\n */\r\nfunction downloadFileOrUrl(pathOrUrl, target)\r\n```",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}